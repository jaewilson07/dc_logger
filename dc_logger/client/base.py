"""Base configuration classes and utilities for the logging library."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/client/base.ipynb.

# %% auto 0
__all__ = ['OutputMode', 'ServiceConfig', 'Handler_BufferSettings', 'ServiceHandler', 'HandlerInstance', 'Logger']

# %% ../../nbs/client/base.ipynb 2
from .Log import LogEntry, LogLevel

# %% ../../nbs/client/base.ipynb 3
from typing import Optional, List, Dict, Any, Literal
from dataclasses import dataclass, field
from abc import ABC, abstractmethod
from enum import Enum



# %% ../../nbs/client/base.ipynb 5
# Type for valid output modes
OutputMode = Literal["cloud", "console", "file", "multi"]


@dataclass
class ServiceConfig(ABC):
    """abstract base class for service-specific configuration settings"""

    output_mode: OutputMode

    def __post_init__(self):
        self.validate_config()


    @abstractmethod
    def validate_config(self) -> bool:
        """Validate the configuration"""
        raise NotImplementedError()

@dataclass
class Handler_BufferSettings(ABC):
    """abstract base configuration for logging configuration settings"""

    batch_size: int = 100
    flush_interval: int = 30  # seconds
    max_buffer_size: int = 1000

@dataclass
class ServiceHandler(ABC):
    """defines how a handler communicates with services to create logs"""

    buffer_settings: Handler_BufferSettings

    service_config: Optional[ServiceConfig] = None # has authentication and connection details to service1

    buffer : List[LogEntry] = field(default_factory = lambda: list )

    # @classmethod
    # def from_config(cls, service_config: ServiceConfig):
        
    #     hc = cls(
    #         service_config = service_config
            
    #     )
        
    #     # if hasattr(config, 'to_platform_config') and callable(getattr(config, 'to_platform_config')):
    #     #     hc.platform_config = config.to_platform_config()
    #     return hc
    
    def validate_config(self) -> bool:
        if not self.service_config:
            raise ValueError("Service configuration is not set.")
        
        return self.service_config.validate_config()

    @abstractmethod
    async def write(self, entries: List[LogEntry]) -> bool:
        """Write log entries to destination"""
        pass

    @abstractmethod
    async def flush(self) -> bool:
        """Flush any buffered entries"""
        pass

    async def close(self):
        """Clean up resources"""
        pass


# %% ../../nbs/client/base.ipynb 6
@dataclass
class HandlerInstance:
    """Wraps a ServiceHandler with filtering logic (log level and method filtering)"""
    
    service_handler: ServiceHandler

    handler_name: str = None # friendly name for the handler

    log_level: LogLevel = LogLevel.INFO  # minimum log level to log.

    log_method: List[str] = field(
        default_factory=lambda: ["POST", "PUT", "DELETE", "PATCH", "COMMENT"]
    )
    # filtered list of API requests to log, generally won't log GET requests

    def __post_init__(self):
        if not self.handler_name:
            self.handler_name = f"{self.service_handler.__class__.__name__}"
        self.validate_config()

    def validate_config(self) -> bool:
        """Validate the configuration"""
        if not self.service_handler:
            raise ValueError("must set a service handler")
        
        return self.service_handler.validate_config()
    
    async def write(self, entry: LogEntry) -> bool:
        """Write log entry to destination with filtering"""
        # Filter by log level
        if entry.level.value < self.log_level.value:
            return False
            
        # Filter by log method
        if entry.method and entry.method not in self.log_method:
            return False
        
        # Delegate to service handler
        await self.service_handler.write([entry])
        return True

    async def flush(self) -> bool:
        """Flush any buffered entries"""
        return await self.service_handler.flush()

    async def close(self):
        """Clean up resources"""
        await self.service_handler.close()

# %% ../../nbs/client/base.ipynb 7
@dataclass 
class Logger:
    """ should receive log entries and send them to all handlers.  handlers will use log_level and log_method to determine which logs to send"""
    
    handlers: List[HandlerInstance] = field(default_factory=list)

    app_name: Optional[str]="default_app"

    async def write(self, entry: LogEntry):
        for handler in self.handlers:
            await handler.write(entry)
    
    def validate_configs(self) -> bool:
        for handler in self.handlers:
            if not handler.config.validate_config():
                return False
        return True

    async def info(self, message: str, **kwargs):
        entry = self.create_entry(LogLevel.INFO, message, **kwargs)
        for handler in self.handlers:
            await handler.write(entry,**kwargs)

    async def debug(self, message: str, **kwargs):
        entry = self.create_entry(LogLevel.DEBUG, message, **kwargs)
        for handler in self.handlers:
            await handler.write(entry)
    
    async def warning(self, message: str, **kwargs):
        entry = self.create_entry(LogLevel.WARNING, message, **kwargs)
        for handler in self.handlers:
            await handler.write(entry)
    
    async def error(self, message: str, **kwargs):
        entry = self.create_entry(LogLevel.ERROR, message, **kwargs)
        for handler in self.handlers:
            await handler.write(entry)

    async def critical(self, message: str, **kwargs):
        entry = self.create_entry(LogLevel.CRITICAL, message, **kwargs)
        for handler in self.handlers:
            await handler.write(entry)

    def create_entry(self, level: LogLevel, message: str, **kwargs):
        entry = LogEntry.create(
            level=level,
            message=message,
            app_name=self.app_name,
            **kwargs
        )
        return entry
    
    # def get_cloud_config(self) -> Dict[str, Any]:
    #     return {"cloud_provider": "multi"}

    # def get_handler_configs(self) -> List[Dict[str, Any]]:
    #     return [
    #         {
    #             "type": handler.type,
    #             "config": handler.config,
    #             "cloud_config": (
    #                 handler.config.to_platform_config()
    #                 if handler.type == "cloud"
    #                 else None
    #             ),
    #         }
    #         for handler in self.handlers
    #     ]

    # @classmethod
    # def create(
    #     cls,
    #     handlers: List[Dict[str, Any]],
    #     level: LogLevel = LogLevel.INFO,
    #     batch_size: int = 100,
    #     flush_interval: int = 30,
    #     **kwargs
    # ) -> "MultiHandlerLogConfig":
    #     handler_configs = [
    #         HandlerConfig(type=h["type"], config=h["config"]) for h in handlers
    #     ]
    #     return cls(
    #         handlers=handler_configs,
    #         level=level,
    #         batch_size=batch_size,
    #         flush_interval=flush_interval,
    #         **kwargs
    #     )

    
