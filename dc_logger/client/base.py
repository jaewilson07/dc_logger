"""Base configuration classes and utilities for the logging library."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/client/base.ipynb.

# %% auto 0
__all__ = ['OutputMode', 'LoggerSettings', 'ServiceConfig', 'ServiceHandler', 'LogLevel', 'LogHandler', 'Logger']

# %% ../../nbs/client/base.ipynb 2
from typing import Optional, List, Dict, Any, Literal
from dataclasses import dataclass, field
from abc import ABC, abstractmethod
from enum import Enum


# %% ../../nbs/client/base.ipynb 3
@dataclass
class LoggerSettings(ABC):
    """abstract base configuration for logging configuration settings"""

    format: str = "json"  # json, text
    batch_size: int = 100
    flush_interval: int = 30  # seconds
    correlation_enabled: bool = True
    include_traceback: bool = True
    max_buffer_size: int = 1000

# %% ../../nbs/client/base.ipynb 4
# Type for valid output modes
OutputMode = Literal["cloud", "console", "file", "multi"]


@dataclass
class ServiceConfig(ABC):
    """abstract base class for service-specific configuration settings"""

    output_mode: OutputMode

    def __post_init__(self):
        self.validate_config()


    @abstractmethod
    def validate_config(self) -> bool:
        """Validate the configuration"""
        raise NotImplementedError()


@dataclass
class ServiceHandler(ABC):
    """defines how a handler communicates with services to create logs"""

    service_config: Optional[ServiceConfig] = None # has authentication and connection details to service1

    @classmethod
    def from_config(cls, service_config: ServiceConfig):
        
        hc = cls(
            service_config = service_config
            
        )
        
        # if hasattr(config, 'to_platform_config') and callable(getattr(config, 'to_platform_config')):
        #     hc.platform_config = config.to_platform_config()
        return hc


# %% ../../nbs/client/base.ipynb 5
class LogLevel(str, Enum):
    """Standard logging levels"""

    DEBUG = "DEBUG"
    INFO = "INFO"
    WARNING = "WARNING"
    ERROR = "ERROR"
    CRITICAL = "CRITICAL"

    @classmethod
    def from_string(cls, level_str: str) -> "LogLevel":
        """Convert string to LogLevel enum"""
        try:
            return cls(level_str.upper())
        except ValueError:
            return cls.INFO  # default fallback

    def should_log(self, other: "LogLevel") -> bool:
        """Check if this level should log the other level"""
        levels = list(LogLevel)
        return levels.index(self) <= levels.index(other)

# %% ../../nbs/client/base.ipynb 6
@dataclass
class LogHandler:
    """defines when, how and where to send log entries"""

    log_config: LoggerSettings
    service_config: ServiceConfig

    log_level: LogLevel = LogLevel.INFO

    log_method : List[str] = field(default_factory=lambda: ["POST", "PUT", "DELETE", "PATCH"])


@dataclass 
class Logger:
    """ should receive log entries and send them to all handlers.  handlers will use log_level and log_method to determine which logs to send"""
    handlers: List[LogHandler] = field(default_factory=list)
    pretty_print: bool = False  # Pretty print JSON for development
