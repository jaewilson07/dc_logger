# Function Call Decorators


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

## Decorator Configuration

Configuration class that accepts injected extractors and processors.
Following the **Dependency Inversion Principle** - depends on
abstractions, not concretions.

------------------------------------------------------------------------

<a
href="https://github.com/jaewilson07/dc_logger/blob/main/dc_logger/client/decorators.py#L27"
target="_blank" style="float:right; font-size:smaller">source</a>

### LogDecoratorConfig

>  LogDecoratorConfig (action_name:Optional[str]=None,
>                          log_level:dc_logger.client.Log.LogLevel=<LogLevel.INF
>                          O: 'INFO'>, entity_extractor:Optional[dc_logger.clien
>                          t.extractors.EntityExtractor]=None, http_extractor:Op
>                          tional[dc_logger.client.extractors.HTTPDetailsExtract
>                          or]=None, multitenant_extractor:Optional[dc_logger.cl
>                          ient.extractors.MultiTenantExtractor]=None, result_pr
>                          ocessor:Optional[dc_logger.client.extractors.ResultPr
>                          ocessor]=None, include_params:bool=False,
>                          sensitive_params:Optional[list]=None)

*Configuration for the log decorator with dependency injection.*

## Main Decorator

The decorator orchestrates all components. It accepts a logger getter
for dependency injection.

------------------------------------------------------------------------

<a
href="https://github.com/jaewilson07/dc_logger/blob/main/dc_logger/client/decorators.py#L68"
target="_blank" style="float:right; font-size:smaller">source</a>

### log_call

>  log_call (logger:Optional[Any]=None,
>                logger_getter:Optional[Callable[[],Any]]=None,
>                action_name:Optional[str]=None,
>                log_level:dc_logger.client.Log.LogLevel=<LogLevel.INFO:
>                'INFO'>, include_params:bool=False,
>                sensitive_params:Optional[list]=None,
>                config:Optional[__main__.LogDecoratorConfig]=None)

\*Decorator to automatically log function calls with full dependency
injection support.

This decorator follows SOLID principles: - Single Responsibility: Each
component has one job - Open/Closed: Extend via custom extractors
without modifying decorator - Liskov Substitution: Any extractor
implementation works - Interface Segregation: Separate interfaces for
different concerns - Dependency Inversion: Depends on abstractions, not
implementations

Args: logger: Direct logger instance (takes precedence) logger_getter:
Callable that returns a logger instance action_name: Custom action name
for logs (defaults to function name) log_level: Minimum log level
(default: INFO) include_params: Whether to include function parameters
in logs sensitive_params: List of parameter names to sanitize config:
LogDecoratorConfig for custom extractors (optional)

Examples: Basic usage:
`python     @log_call(logger_getter=get_logger)     async def my_function():         pass`

    With common options:
    ```python
    @log_call(
        logger_getter=get_logger,
        action_name="custom_action",
        log_level=LogLevel.DEBUG,
        include_params=True
    )
    async def my_function(param1, param2):
        pass
    ```

    With custom extractors:
    ```python
    @log_call(
        logger_getter=get_logger,
        config=LogDecoratorConfig(
            entity_extractor=MyCustomEntityExtractor(),
            result_processor=MyCustomResultProcessor()
        )
    )
    async def my_function():
        pass
    ```

    Combined usage:
    ```python
    @log_call(
        logger_getter=get_logger,
        action_name="process_order",
        log_level=LogLevel.INFO,
        include_params=True,
        config=LogDecoratorConfig(entity_extractor=OrderExtractor())
    )
    async def process_order(order_id, customer_id):
        pass
    ```*

## Helper Functions

Internal implementation details for executing functions with logging.
